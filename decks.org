* Scala                                                                :deck: 
** first n                                                             :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330349906
   :END:
*** Front
    get first n elements of sequence in scala
*** Back
#+begin_src scala  
seq.take(n)
#+end_src
** concat sequences                                                    :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330350091
   :END:
*** Front
    combine two sequences in Scala
*** Back
#+begin_src scala 
seq1 ++ seq2
#+end_src

** string from seq scala                                               :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330350305
   :END: 
*** Front
join a sequence with a delimiter in scala

*** Back
~seq.mkString(delim)~
** scala elementwise comparison                                        :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330350490
   :END: 
*** Front
get the element-wise comparison of two sequences in scala
*** Back
~seq1.deep == seq2.deep~
** scala nested loop                                                   :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330350709
   :END: 
*** Front
construct a nested loop in scala
*** Back
~for (x <- xs; y <- ys) {}~
** create a list by repeating in scala                                 :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330350893
   :END: 
*** Front
Repeat item i n times to form a list in scala
*** Back
#+begin_src scala
List.fill(n)(i)
#+end_src 
** get the current timestamp in scala                                  :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330351133
   :END: 
*** Front
Get the current timestamp in Scala (and Java)
*** Back
#+begin_src scala
java.Time.LocalDateTime.now()
#+end_src  

** top class in scala                                                  :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1519849321411
   :END:
*** Front
    The class at the root of Scala's class hierarchy
*** Back
    ~Any~
** Scala Paradigms                                                     :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849321823
   :END:
*** Text
    In Scala, every value is {{c1:: an object}}, and every function is {{c2::a value}}.
*** Extra
** vals are what?                                                      :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849322059
   :END:
*** Front
    Can you reassign a ~val~ in Scala?
*** Back
    No
** Explicit type declaration                                           :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849322249
   :END:
*** Front
    Explicitly assign a type to a ~var~
*** Back
    ~var i: Int = 3~
** Lambda structure                                                    :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1519849322439
   :END:
*** Text
    The basic structure of an anonymous function in Scala is:
    ~({{c1:: parameters)}} => {{c2::expression}}~
*** Extra
** function/method                                                     :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849322632
   :END:
*** Front
    Does ~def~ define a function or a method?
*** Back
    A method
** Unit/void                                                           :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849322866
   :END:
*** Front
    The return value of a function with no meaningful return value
*** Back
    ~Unit~
** Case class comparison                                               :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849323030
   :END:
*** Front
    How are two case classes compared?
*** Back
    By their value
** Case class mutability                                               :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849323191
   :END:
*** Front
    Can you modify a case class?
*** Back
    By default, no.
** singletons                                                          :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849323458
   :END:
*** Front
    Declare a singleton called "Orb"
*** Back
#+BEGIN_SRC scala 
object Orb {
// values and methods go here
}
#+end_src
** a use for traits                                                    :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849323651
   :END:
*** Front
    How would you build a class out of more generic reusable values and methods?
*** Back
    By using traits.
** Core application logic                                              :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[http://docs.scala-lang.org/tour/tour-of-scala.html][Scala Official Introduction]]
   :ANKI_NOTE_ID: 1519849407987
   :END:
*** Front
    In a basic Scala application, where would you put the main logic?
*** Back
#+BEGIN_SRC scala
object Main {
  doSomething()
}
#+END_SRC

** pattern guard basics                                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-05 Mon]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1520285126940
   :END: 
*** Front
Pattern match x against an evaluation expression
*** Back
#+begin_src scala 
x match {
  case x if evaluate(x) => true
  case _ => false
}
#+end_src
** scala first iterator                                                :note:
   :PROPERTIES: 
   :CREATED:  <2018-03-05 Mon>
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :ANKI_NOTE_ID: 1520287206785
   :END: 
*** Front
Get the first element of an iterator (e.g. to use as an example of what it produces)
*** Back
~iterator.first~
** scala pairwise combinations                                         :note:
   :PROPERTIES: 
   :CREATED:  <2018-03-05 Mon>
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :ANKI_NOTE_ID: 1520287207065
   :END: 
*** Front
Get the pairwise combinations of all the (unique) elements of a sequence ~seq~
*** Back
~seq.combinations(2)~
** require syntax                                                      :note:
   :PROPERTIES: 
   :CREATED:  <2018-03-06 Tue>
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1520379519476
   :END: 
*** Front
Require an argument to be within a specified range of values
*** Back
#+begin_src scala 
def func(x: Int): Int = {
  require(checkRange(x))
  doSomething(x)
}
#+end_src
** group a list                                                        :note:
   :PROPERTIES: 
   :CREATED:  <2018-03-06 Tue>
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :ANKI_NOTE_ID: 1520379519844
   :END: 
*** Front
Get ~Map(1 -> Array(2,3), 2 -> Array(4))~ from ~Array((1,2),(1,3),(2,4))~
*** Back
#+begin_src scala 
Array((1,2),(1,3),(2,4))
  .groupBy(_._1)
  .mapValues(_.map(_._2))
#+end_src
** literally                                                           :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522259204059
   :END: 
*** Front
 Why are literals called literals?
*** Back
 "...because they literally look like what they evaluate to."

** compilation sequence
:PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Cloze
   :SOURCE:   Essential Scala, chapter 2
   :END: 
*** Text
 The scala compiler checks {{c1::syntax}}, then {{c2::types}} (aka {{c3::semantics}}).

*** Extra

** failing at runtime
:PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   Essential Scala, chapter 2
   :END: 

*** Front
 Can a successfully compiled Scala program fail at runtime?
*** Back
 Yes, if it triggers an exception.
** Option pattern                                                      :note:
   :PROPERTIES:
   :CREATED:  [2018-03-16 Fri]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522259204242
   :END:

*** Front

How would you write a function that returns no value when necessary?

*** Back

#+begin_src scala
def myFunc(ss: String): Option[String] = {
  if (checkString(ss)) {Option(ss)}
  else {None}
}
#+end_src

** values and types                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522259204394
   :END: 
*** Front
Why don't values have types?
*** Back
Because values are just arbitrary bits in the computer's memory.

** types, values, expressions                                          :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Cloze
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522259269386
   :END: 
*** Text
    {{c1:: Expressions}} have types, but {{c2:: values}} do not.
*** Extra
** failing at runtime                                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522259204647
   :END: 
*** Front
Can a compiled Scala program fail at runtime?
*** Back
Yes, if it triggers an exception.
** sbt dependencies                                                    :note:
   :PROPERTIES:
   :CREATED:  [2018-03-16 Fri]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522259204779
   :END:

*** Front

In a SBT project, where do you declare your dependencies?

*** Back
 ~/projectpath/project/build.sbt~

** empty mutable array                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-27 Tue]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522259205027
   :END: 
*** Front
How do you create an empty mutable array of strings?
*** Back
~scala.collection.mutable.ArrayBuffer[String]()~

** sbt reload                                                          :note:
   :PROPERTIES:
   :CREATED:  [2018-03-22 Thu]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522259205206
   :END:

*** Front

In sbt, how would you set the project to a different version of scala or a library?

*** Back

~sbt reload~

** Can you treat values of Some() the same?                            :note:
   :PROPERTIES:
   :CREATED:  [2018-03-19 Mon]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522259205379
   :END:

*** Front

Can you treat values of Some() the same as their contained values?

*** Back

No.

** type erasure                                                        :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522263832729
   :END: 
*** Front
After a program compiles, what happens to the type information?
*** Back
It is no longer needed, so it is removed.
** object data                                                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522263832980
   :END: 
*** Front
Where does an object keep its data?
*** Back
In fields.
** infix operators                                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522263833126
   :END: 
*** Front
a.b(c) =
*** Back
a b c =
** literals and values                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Cloze
   :SOURCE: Essential scala, chapter 2
   :ANKI_NOTE_ID: 1522263833321
   :END: 
*** Text
The {{c1::literal expression}} is the {{c2::representation in the program text}}, before the program is run, and the {{c3::value}} is the {{c4::representation in the computer’s memory}} after the program has run.
*** Extra
** alternative to null                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522263833553
   :END: 
*** Front
What should you use in lieu of null in scala?
*** Back
None
** why not use null?                                                   :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1522263833689
   :END: 
*** Front
Why is it bad to use nulls in Scala?
*** Back
They can't be checked by the compiler, which hobbles the type system.
** object declaration                                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-03-28 Wed]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522263833820
   :END: 
*** Front
Is ~object Test {}~ an expression?
*** Back
No, it has no value - not even ~Unit~
** package compilation                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-02 Mon]
   :ANKI_NOTE_TYPE: Basic
  :SOURCE: trial and error with SBT
  :ANKI_NOTE_ID: 1522710430815
   :END: 
*** Front
Why won't my class import from the package I defined?
*** Back
Because you haven't recompiled the project recently.
** apply a list of methods to an expression                            :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-03 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://stackoverflow.com/questions/8550356/array-of-functions][Stack Overflow]]
   :ANKI_NOTE_ID: 1523048584600
   :END: 
*** Front
Apply multiple functions to an expression via an array
*** Back
#+begin_src scala
Array(addOne _, addTwo _).map(_(1))
#+end_src
** return types                                                        :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-06 Fri]
   :ANKI_NOTE_TYPE: Basic
  :SOURCE: Essential Scala, chapter 2
  :ANKI_NOTE_ID: 1523048584779
   :END: 
*** Front
Do you have to specify the return type of a method?
*** Back
No, but it's strongly encouraged!
** overloading float and int                                           :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-06 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1523048584955
   :END: 
*** Front
What's the best way to write a method that handles both floats and ints?
*** Back
Method overloading is the best way, because floats and ints are primitive types.
** singleton method                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-09 Mon]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1523306948403
   :END: 
*** Front
How would you write a method for another object or class to operate on a singleton object?
*** Back
#+begin_src scala
def getValue(s: singleton.type): Any = {
  s.value
}
#+end_src
** scala design recipe                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-09 Mon]
   :ANKI_NOTE_TYPE: Cloze
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1523306948555
   :END: 
*** Text
To write a method in scala, 

1.  Identify {{c1::inputs and outputs}}
2. Prepare {{c2::test cases}}
3. Write {{c3:: the method template using ???}}
4. {{c4:: test the code and observe the failures}}
5. {{c5:: work forwards from input, and backwards from output to build the body}}
6. {{c6:: run the code again and observe the passes}}
*** Extra

** conditional expression branches                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1523378877988
   :END: 
*** Front
Does the unchosen branch of a conditional expression get evaluated to a value?
*** Back
No.
** Where does ~Any~ show up?                                           :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 2
   :ANKI_NOTE_ID: 1523378878233
   :END: 
*** Front
What's the type of an unevalutated expression that evaluates to more than one type?
*** Back
~Any~
** type of ~Unit~                                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
  :SOURCE: Essential Scala, chapter 2
  :ANKI_NOTE_ID: 1523378878395
   :END: 
*** Front
What's the type of the value ~Unit~?
*** Back
~Any~
** names of objects                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378878575
   :END: 
*** Front
What does an object declaration do instead of evaluating an expression?
*** Back
It binds a name.
** Scala interop 101                                                   :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378878802
   :END: 
*** Front
What are all Scala classes subclasses of?
*** Back
~java.lang.Object~
** define class fields instantly!                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378879979
   :END: 
*** Front
How would you easily assign a class constructor's values to fields?
*** Back
#+begin_src scala
class Person(val first: String, val last: String) {
  def name = first + " " + last
}
#+end_src
** Text
#+begin_src scala

class {{c1::Name}}({{c2::val}} {{c3::parameter}}: {{c4::type}}, ...) {
  {{c5::declarationOrExpression}} ...
}

#+end_src
** keyword params                                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378880188
   :END: 
*** Front
Why are keyword parameters useful?
*** Back
"Keyword parameters are robust to changes in the number and order of parameters."
** ~Any~'s subtypes                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378880316
   :END: 
*** Front
What are the two subtypes of ~Any~?
*** Back
~AnyVal~ and ~AnyRef~
** ~AnyVal~ basics                                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378880442
   :END: 
*** Front
The type that all values are subtypes of
*** Back
~AnyVal~
** ~AnyRef~ basics                                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378880645
   :END: 
*** Front
The type that all objects are subtypes of
*** Back
~AnyRef~ = ~java.lang.Object~
** the bottom of scala's type heap                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378880771
   :END: 
*** Front
What types are /subtypes/ of every other type?
*** Back
~Nothing~ and ~Null~
** ~Nothing~ basics                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378880971
   :END: 
*** Front
The type of throw expressions
*** Back
~Nothing~
** ~Null~ basics                                                       :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378881099
   :END: 
*** Front
The type of the value ~null~
*** Back
~Null~
** why give ~null~ a type?                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chaper 3
   :ANKI_NOTE_ID: 1523378881230
   :END: 
*** Front
Why does ~null~ have a type?
*** Back
So we can reason about ~nulls~ in Scala's type system.
** Why give throws a type?                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1523378881434
   :END: 
*** Front
Why do throw expressions have a type in Scala?
*** Back
So that we can reason about exceptions in Scala's type system.
** transpose lists                                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-16 Mon]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1524091060207
   :END: 
*** Front
get the index/element-wise matches from an arbitrary number of lists
*** Back
#+BEGIN_SRC scala
list(l1, l2, ln).transpose
#+END_SRC
** compile test sources without running                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-18 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://stackoverflow.com/questions/13847109/how-to-compile-tests-with-sbt-without-running-them][Stack Overflow]]
   :ANKI_NOTE_ID: 1524091060352
   :END: 
*** Front
In SBT, how would you compile the source code of the unit tests without running them?
*** Back
#+BEGIN_SRC shell
sbt compile:test
#+END_SRC
** call an object like a function                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-19 Thu]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1524173272808
   :END: 
*** Front
How do you call an object like a function?
*** Back
#+BEGIN_SRC scala
object myObj{
  def apply(input: Any): Any = doSomething(input)
}
#+END_SRC
** method arg                                                          :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-19 Thu]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3
   :ANKI_NOTE_ID: 1524173272972
   :END: 
*** Front
Can you pass a method as an argument?
*** Back
No.
** methods vs functions, pt 1                                          :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-19 Thu]
   :ANKI_NOTE_TYPE: Basic
  :SOURCE: Essential Scala, chapter 3
  :ANKI_NOTE_ID: 1524173273126
   :END: 
*** Front
Why is it good that functions are objects in Scala?
*** Back
"Unlike methods, objects can be passed around as data."

** companion objects                                                   :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-19 Thu]
   :ANKI_NOTE_TYPE: Basic
  :SOURCE: Essential Scala, chapter 3
  :ANKI_NOTE_ID: 1524173273262
   :END: 
*** Front
If you wanted to add functionality to an entire class rather than a specific instance, you would use:
*** Back
A companion object.
** companion objects #2                                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-19 Thu]
   :ANKI_NOTE_TYPE: Basic
  :SOURCE: Essential Scala, chapter 3, [[http://fruzenshtein.com/scala-case-class-companion-object/][Fruzenshtein Notes]], & [[https://softwareengineering.stackexchange.com/questions/179390/what-are-the-advantages-of-scalas-companion-objects-vs-static-methods][Stack Overflow]]
  :ANKI_NOTE_ID: 1524173273465
   :END: 
*** Front
What's the primary advantage of companion objects?
*** Back
They enforce a clear separation between run-time data and compile-time methods.
** add item to list                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Trial and error
   :ANKI_NOTE_ID: 1525385017250
   :END: 
*** Front
Return a new list ~l~ with element ~i~ added
*** Back
~l :+ i~
** static vs not static methods                                        :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-09 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 3, [[https://stackoverflow.com/questions/2671496/java-when-to-use-static-methods][Stack Overflow]]
   :ANKI_NOTE_ID: 1526312625344
   :END: 
*** Front
When would you put a method in a companion object?
*** Back
When you want a static method - a method that can be used without creating an instance of the object.
** vals in traits                                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-11 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1526312625565
   :END: 
*** Front
Should you use vals in a trait?
*** Back
No, you should use def.
** sealed trait inheritance/extension                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-15 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Essential Scala, chapter 4, trial and error
   :ANKI_NOTE_ID: 1526913598537
   :END: 
*** Front
The compiler warns you about a match expression - you're not using a trait that extends a sealed trait.
*** Back
Make the inheritor trait sealed as well, and ensure all types that extend it are in the match expression.

** sum type pattern implementation                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1527007267451
   :END: 
*** Front
implement the sum type pattern
*** Back
#+BEGIN_SRC scala
sealed trait A
final case class B() extends A
final case class C() extends A
#+END_SRC
** the sum type pattern (description)                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1527007267591
   :END: 
*** Front
Another way of describing the sum type pattern
*** Back
A is a B /or/ C
** product type pattern implementation (class)                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1527007267837
   :END: 
*** Front
Implement the product type pattern as a class
*** Back
#+BEGIN_SRC scala
case class A(b: B, c: C)
#+END_SRC
** product type pattern implementation (trait)                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1527007267970
   :END: 
*** Front
Implement the product type pattern as a trait
*** Back
#+BEGIN_SRC scala
trait A {
  def b: B 
  def c: C
}
#+END_SRC
** product type description                                            :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1527007268131
   :END: 
*** Front
Another way of describing the product type pattern
*** Back
A has a B /and/ C
** consider a case object instead                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Essential Scala, chapter 4
   :ANKI_NOTE_ID: 1527007321199
   :END: 
*** Front
You haven't yet specified how instances of this class might differ from one another.
*** Back
A case object might be a good idea.
** scaladoc for classes                                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-24 Thu]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://issues.scala-lang.org/browse/SI-577][Scala JIRA (legacy)]]
   :ANKI_NOTE_ID: 1527264158910
   :END: 
*** Front
Document the parameters in a class
*** Back
#+BEGIN_SRC scala
/** The smallest representation of a row of data.
  * @param id the dimension (index) of the data
  * @param value the data's value
  */
case class A(id: Int, value: Double)

#+END_SRC

** stable string hashes                                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-25 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://www.scala-lang.org/api/2.12.2/scala/util/hashing/MurmurHash3$.html][Scala Standard Library]]
   :ANKI_NOTE_ID: 1527264159074
   :END: 
*** Front
ensure that a string is consistently hashed
*** Back
#+BEGIN_SRC scala
scala.util.hashing.MurmurHash3.stringHash(str)
#+END_SRC
* Spark                                                                :deck: 
** udf on list of columns                                              :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330296324
   :END:
*** Front
    apply a udf to a list of columns in spark
*** Back
#+begin_src scala 
var tempdf = df
cols.map{c => tempdf.withColumn(c, udf(col(c)))}
#+end_src 
** select column sequence                                              :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330296492
   :END:
*** Front
select a sequence of column names in Spark
*** Back
#+begin_src scala 
df.select(cols.head, cols.tail: _*)
#+end_src

** basic model                                                         :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330100262
   :END:

*** Front
High-level summary of any Spark program

*** Back
1. represent data as collection of RDDs
2. build up a series of lazy transformations on those RDDs
3. perform actions to get the results of those transformations
** spark row to sequence                                               :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330296951
   :END: 
*** Front
Convert a Row to a sequence in Spark
*** Back
#+begin_src scala
Row.toSeq 
#+end_src
** spark join by row number :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1517936166278
:END:

*** Front

Get the row number of a dataframe in spark

*** Back

#+begin_src scala 
df.rdd.zipWithIndex
#+end_src 

** count null values in a spark column :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1517936166520
:END:

*** Front

Find the count of null values in column "x" of a DataFrame df

*** Back

#+begin_src scala
df.filter(df("x").isNull).count()
#+end_src

** filter out the NaN values in a Spark dataframe :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1517936166738
:END:

*** Front

Filter the NaN values out of column y in a Spark DataFrame

*** Back

#+begin_src scala 
val filteredDF = df.filter(!df("y").isNaN)
#+end_src 

** spark drop all nulls :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1517936166950
:END:

*** Front

Get rid of any rows with null or NaN values from a df in Spark

*** Back

#+begin_src scala
df.na.drop()
#+end_src

** spark chi-squared two vectors                                       :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :CREATED: <2018-02-06 Tue>
   :ANKI_NOTE_ID: 1518118509892
   :END: 
*** Front
Compare the distributions of two vectors using a chi-squared test in Spark
*** Back
#+begin_src scala 
Statistics.chiSqTest(vec1, vec2)
#+end_src
** aws s3 credentials in bucket path                                   :note:
:PROPERTIES:
:CREATED:  <2018-02-15 Thu>
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1519829628284
:END:

*** Front

Send AWS S3 credentials with a s3 bucket path on databricks / spark

*** Back

s3a://ACCESS_KEY_ID:SECRET_ACCESS_KEY@full_bucket_name/path/to/file
** deal with serialization errors                                      :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1521039944684
   :END:
*** Front
How do you deal with a class or method that throws a serialization error?
*** Back
#+begin_src scala
object Wrapper extends java.io.Serializable {
// classes and methods go here
}

#+end_src
** Unit testing in spark                                               :note:
   :PROPERTIES:
   :CREATED:  [2018-03-14 Wed]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1522259207455
   :END:

*** Front

If you're unit testing in spark,

*** Back

You'd better make sure you're writing examples that operate on rows and DFs too.

** style: DFs                                                          :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-02 Mon]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://github.com/MrPowers/spark-style-guide][Matthew Powers' Spark Style Guide]]
   :ANKI_NOTE_ID: 1522710433062
   :END: 
*** Front
The format for variables pointing to DFs
*** Back
~deviceDF.createOrReplaceTempView("device")~
** get test DF from SBT resources                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-03 Tue]
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1523048587334
   :END: 
*** Text
To get Spark sample data from a SBT project, use
#+begin_src scala
val testDF = {{c1::sparkContext.parallelize}}(
  {{c1::Source.fromUrl}}(
  {{c3::getClass}}.{{c4::getClassLoader}}.{{c5::getResource}}("test.csv")
  ).{{c6::mkString}}.{{c7::split("\n")}}
).toDF

#+end_src
*** Extra

** avoid aggregation bottleneck                                        :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-10 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://stackoverflow.com/questions/45704156/what-is-the-difference-between-spark-sql-shuffle-partitions-and-spark-default-pa][Stack Overflow]]
   :ANKI_NOTE_ID: 1523378883961
   :END: 
*** Front
How would you avoid a memory bottleneck when performing an aggregation?
*** Back
#+begin_src scala
sqlContext.setConf("spark.sql.shuffle.partitions", x)
#+end_src
** udf for row                                                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-11 Wed]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://stackoverflow.com/questions/42931796/spark-udf-for-structtype-row][Stack Overflow]]
   :ANKI_NOTE_ID: 1524091062730
   :END: 
*** Front
Write a UDF that operates on a Row type
*** Back
#+begin_src scala

val u = udf((x: Row) => x, rowSchema)

#+end_src
** spark sql views considered harmful                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-18 Wed]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1524090986095
   :END: 
*** Front
Why is it better to avoid the use of sql strings in large Spark programs?
*** Back
Because the compiler can't check the results of the queries embedded in those strings.
** create a dataframe from scratch                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-25 Wed]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1524694460403
   :END: 
*** Front
Create a dataframe with a string column ss, a Double column v, and an Int column ix
*** Back
#+BEGIN_SRC scala
val rowData = ("s01", 4.5, 0)
val dataDF = sc.parallelize(Seq(rowData)).toDF("ss", "v", "ix")

#+END_SRC
**  db command mode switch                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851837717
   :END: 
*** Front
Switch to command mode in Databricks
*** Back
~<ESC>~
** databricks find/replace                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks Self-Documentation
   :ANKI_NOTE_ID: 1524851837940
   :END: 
*** Front
In Databricks edit mode, perform a find/replace
*** Back
~<Ctrl> <Alt> <F>~
** databricks run + insert                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851838094
   :END: 
*** Front
In Databricks, execute a command and insert a new cell
*** Back
~<Alt> + <Enter>~
** db vanilla run command                                              :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851838245
   :END: 
*** Front
Run a command in databricks and remain at the same cell
*** Back
~<Ctrl> + <Enter>~
** db run all above commands up to                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851838459
   :END: 
*** Front
Run all databricks cells up to the current cell
*** Back
~<Shift> + <Alt> + <Up>~
** db run all up to current                                            :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851838606
   :END: 
*** Front
In databricks, run all cells /including/ the current
*** Back
~<Shift> + <Alt> + <Down>~
** db jump up or down                                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851838734
   :END: 
*** Front
Jump up or down a cell in databricks
*** Back
~<Ctrl> + <Up> / <Down>~
** DB cell above                                                       :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851838941
   :END: 
*** Front
Insert a databricks cell above
*** Back
~<Ctrl> + <Alt> + <P>~
** DB cell below                                                       :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851839087
   :END: 
*** Front
Insert a databricks cell below
*** Back
~<Ctrl> + <Alt> + <N>~
** DB split cell                                                       :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851839224
   :END: 
*** Front
Split the databricks cell at the cursor
*** Back
~<Ctrl> + <Alt> + <->~
** db move cell up/down                                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851839453
   :END: 
*** Front
Move a databricks cell up/down
*** Back
~<Ctrl> + <Alt> + <Up>/<Down>~
** db toggle comments                                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851839591
   :END: 
*** Front
Toggle the databricks comments panel
*** Back
~<ctrl> + <alt> + <M>~
** Copy DB cell                                                        :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851839728
   :END: 
*** Front
Copy the current databricks cell
*** Back
~<Ctrl> + <Alt> + <C>~
** Cut DB cell                                                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851839940
   :END: 
*** Front
Cut the current databricks cell
*** Back
~<Ctrl> + <Alt> + <X>~
** Paste DB cell                                                       :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851840078
   :END: 
*** Front
Paste the current databricks cell
*** Back
~<Ctrl> + <Alt> + <V>~
** Delete DB cell                                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851840226
   :END: 
*** Front
Delete the current databricks cell
*** Back
~<Ctrl> + <Alt> + <D>~
** Databricks unindent                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851840435
   :END: 
*** Front
Unindent a selection in databricks
*** Back
~<Shift> + <Tab>~
** Indent a databricks selection                                       :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851840581
   :END: 
*** Front
Indent a selection in a databricks cell
*** Back
~<Tab>~
** Databricks comment line                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851840740
   :END: 
*** Front
Comment a line in databricks
*** Back
~<Ctrl> + </>~
** DB select multiple                                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851840970
   :END: 
*** Front
Select multiple databricks cells
*** Back
~<Ctrl> + <Click>~
** DB command delete                                                   :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851841112
   :END: 
*** Front
Quickly delete a cell in databricks
*** Back
~<Shift> + <D> <D>~
** DB command cut/copy/paste                                           :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851841242
   :END: 
*** Front
In command mode, what are the commands for cut, copy, and paste?
*** Back
~<X> <C> <V>~
** db command paste above                                              :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851841451
   :END: 
*** Front
In databricks command mode, paste a cell above the current point
*** Back
~<Shift> + <V>~
** DB command insert below                                             :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851841602
   :END: 
*** Front
In databricks command mode, insert a cell below
*** Back
~<B>~
** DB command scroll up/down                                           :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851841762
   :END: 
*** Front
In databricks command mode, scroll up or down
*** Back
~<Space>  / <Shift> + <Space>~
** DB command help                                                     :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851841993
   :END: 
*** Front
In databricks command mode, toggle the shortcuts menu
*** Back
~<H>~
** DB command merge                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851842147
   :END: 
*** Front
In databricks command mode, merge the current cell with the one below
*** Back
~<Shift> + <M>~
** DB command move up                                                  :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851842280
   :END: 
*** Front
Move to previous cell in databricks command mode
*** Back
~<P> / <K>~
** DB command move down                                                :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851842487
   :END: 
*** Front
Move to next cell in Databricks command mode
*** Back
~<N> / <J>~
** DB command toggle line numbers                                      :note:
   :PROPERTIES: 
   :CREATED:  [2018-04-27 Fri]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Databricks self-documentation
   :ANKI_NOTE_ID: 1524851842632
   :END: 
*** Front
Toggle line numbers in DB command mode
*** Back
~<L>~

** col with period in it                                               :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-08 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Trial and error
   :ANKI_NOTE_ID: 1526312632802
   :END: 
*** Front
Your column name has a period in it.
*** Back
Replace it with a different character
** geospark load wkt                                                   :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-08 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Geospark documentation
   :ANKI_NOTE_ID: 1526312633012
   :END: 
*** Front
Load a wkt column in geospark
*** Back
#+BEGIN_SRC scala
val parsedDF = df.selectExpr("*", "ST_GeomFromWKT(wkt) AS geom")
#+END_SRC
** geospark spatial join                                               :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-08 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Geospark documentation
   :ANKI_NOTE_ID: 1526312633198
   :END: 
*** Front
Perform a spatial join in geospark
*** Back
#+BEGIN_SRC scala
df1.createOrReplaceTempView("df1")
df2.createOrReplaceTempView("df2")
#+END_SRC

#+BEGIN_SRC sql
%sql
SELECT * FROM df1, df2 WHERE ST_Intersects(df1.geom, df2.geom)
#+END_SRC
** joining DFs                                                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-14 Mon]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://stackoverflow.com/a/43518900][Stack overflow]]
   :ANKI_NOTE_ID: 1526312633431
   :END: 
*** Front
What's the best way to join a list of dataframes without using ~unionAll~ (e.g. without an initial DF?)
*** Back
#+BEGIN_SRC scala
dfs.reduce(_.union(_))
#+END_SRC
** explicitly set sub-partitions in spark                              :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-21 Mon]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://spark.apache.org/docs/2.3.0/api/scala/index.html#org.apache.spark.sql.Dataset][Spark Dataset API documentation]]
   :ANKI_NOTE_ID: 1526913598713
   :END: 
*** Front
Set the number of sub-partitions to use when repartitioning by a column
*** Back
#+BEGIN_SRC scala
df.repartition(numPartitions=n, $"colName")
#+END_SRC
** rangePartitioner                                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-21 Mon]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: [[https://spark.apache.org/docs/2.3.0/api/scala/index.html#org.apache.spark.RangePartitioner][Spark RangePartitioner API docs]]
   :ANKI_NOTE_ID: 1526913598868
   :END: 
*** Front
When you want to repartition and evenly distribute the values of a sortable column into n groups
*** Back
#+BEGIN_SRC scala
df.repartitionByRange(numPartitions=n, $"colName")
#+END_SRC
** convert DF to Dataset                                               :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-22 Tue]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Spark: The Definitive Guide, chapter 11
   :ANKI_NOTE_ID: 1527007277336
   :END: 
*** Front
Convert a DataFrame to a Dataset
*** Back
#+BEGIN_SRC scala
val sampleDataset = sampleDF.as[DataCaseClass]
#+END_SRC
* Emacs                                                                :deck: 
** remove agenda filter                                                :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1516568999718
   :END:

*** Front
remove the filter from emacs/org-agenda
*** Back
|
** dired sort switch                                                   :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1516568999923
   :END:

*** Front
switch buffer sorting modes in emacs/dired
*** Back
s
** variable name                                                       :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1516569000084
   :END:

*** Front
find the name of a variable in emacs

*** Back
M-x describe-variable
** magit history                                                       :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330379270
   :END: 
*** Front 
 Show a repo's history in magit
*** Back
    "l l"
(that's "L", but lowercase)
** org agenda bulk command in emacs                                    :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330379456
   :END: 
*** Front
In emacs' org-agenda, execute a bulk command on marked files
*** Back
"B"
** clock into a task from org-agenda                                   :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330379669
   :END: 
*** Front
Clock into a task from org-agenda
*** Back
"I"
(that's a capital "i")
** cider get buffer namespace                                          :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330379858
   :END: 
*** Front
In CIDER/emacs, jump into the buffer's clojure namespace
*** Back
M-x cider-repl-set-ns
** org agenda priority :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1517936107413
:END:

*** Front

Set the priority of an item in org agenda

*** Back

"," or "-"

** org link format                                                     :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1518118450414
   :END: 
*** Front
The plaintext format for links in org-mode
*** Back
=[ [link url][description] ]=
(without spaces)
** override org syntax                                                 :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1518118450741
   :END: 
*** Front
Turn off org mode syntax for "this text"
*** Back
= "this text" = (without spaces)
** emacs tramp file                                                    :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1518118450982
   :END: 
*** Front
Use tramp for remote editing of a file in emacs
*** Back
C-o (find file)
/ssh:user@server:path/to/file
** filter by top-level headline in org-agenda                          :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1519829668647
:END:

*** Front

Filter by top-level headline or project in org-agenda

*** Back

"^"

** org agenda views                                                    :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1519829668859
:END:

*** Front

Toggle the views in org agenda

*** Back

"v"

** org italics                                                         :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1519829669051
:END:

*** Front

Make "text" italic in org mode

*** Back

Wrap "text" in slashes

** magit discard change                                                :note:
   :PROPERTIES: 
   :CREATED:  <2018-03-03 Sat>
   :ANKI_NOTE_TYPE: Basic
   :SOURCE:   [[https://github.com/magit/magit/wiki/Cheatsheet][magit cheatsheet]]
   :ANKI_NOTE_ID: 1520287207229
   :END: 
*** Front
Discard change at point in magit

*** Back
 k
* Clojure                                                              :deck:
** iterable clojure                                                    :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330487212
   :END: 
*** Front
Check if a value is sequential in clojure
*** Back
#+begin_src clojure
(sequential? s)
#+end_src 
** get the type of a value in clojure :note:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1517936213844
:END:

*** Front

Get the type of a value v in clojure

*** Back
#+begin_src clojure
(class v)
#+end_src
** set up a dynamic sketch in clj/quil                                 :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1518118489452
   :END: 
*** Front
In quil, set up a dynamic sketch in clojure from the REPL
*** Back
#+begin_src clojure 
(use 'sketch.core)
#+end_src
** multi-arg function                                                  :note:
   :PROPERTIES: 
   :CREATED:  <2018-03-03 Sat>
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1520287208068
   :END: 
*** Front
Specify a variable number of arguments in a function definition
*** Back
~[& args]~
** random float                                                        :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-18 Fri]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1527606590625
   :END: 
*** Front
get a random float between 0 and n
*** Back
#+BEGIN_SRC clojure
(rand n)
#+END_SRC

** random int                                                          :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-18 Fri]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1527606590836
   :END: 
*** Front
Get a random int between 0 and n (exclusive)
*** Back
#+BEGIN_SRC clojure
(rand-int n)
#+END_SRC
** clojure random item                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-18 Fri]
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1527606590970
   :END: 
*** Front
Pick a random item from a list
*** Back
#+BEGIN_SRC clojure
(rand-nth list)
#+END_SRC
* Data Science                                                         :deck:
** k-means step                                                        :note:
   :PROPERTIES: 
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517330514396
   :END: 
*** Front
in each refinement step of k-means, the cluster is updated by taking a ______ from the assigned points
*** Back
centroid (which is a linear combination of the points' features) 
** chi-squared probability                                             :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1517940754388
   :END:
*** Front
In a chi-squared test, what does the p-value measure the probability of?
*** Back
The difference between the observed and expected distribution happening by chance
** dispersion / sum of squares                                         :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-30 Wed]
   :ANKI_NOTE_TYPE: Basic (and reversed card)
   :SOURCE: Data Science from Scratch, chapter 5
   :ANKI_NOTE_ID: 1527694810877
   :END: 
*** Front
Another way of describing dispersion
*** Back
The average squared distance of data points from the mean.
* Programming Methods                                                  :deck:
** Stuck on functions                                                  :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1521039211841
   :END:
*** Text
If you're stuck when writing a function, {{c1:: think of it in its mathematical sense}}: {{c2:: a continuous mapping from inputs to outputs}}, rather than {{c3:: a sequence of imperative instructions}}.
*** Extra
** Template types                                                      :note:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1521039211999
   :END:
*** Text
When you can, keep templates for {{c1:: data types}} separate from templates for {{c2:: functions}}.
*** Extra
* Python                                                               :deck:
** Holoviews color a category                                          :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-03 Thu]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: [[https://stackoverflow.com/questions/47657085/holoviews-color-per-category][Stack Overflow]]
   :ANKI_NOTE_ID: 1525385027889
   :END: 
*** Front
Assign colors to categorical data in a Holoviews plot object
*** Back
#+BEGIN_SRC python

hv_plot_obj.opts(plot={'color_index':'category'})

#+END_SRC
** holoviews no border                                                 :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-03 Thu]
   :ANKI_NOTE_TYPE: Basic
   :SOURCE: Trial and error
   :ANKI_NOTE_ID: 1525385028029
   :END: 
*** Front
remove the border line from a single HoloViews Polygon object
*** Back
#+BEGIN_SRC python
poly_obj.opts(style={'line_alpha':0})
#+END_SRC
** holoviews make selectable layers                                    :note:
   :PROPERTIES: 
   :CREATED:  [2018-05-03 Thu]
   :ANKI_NOTE_TYPE: Cloze
   :SOURCE: [[http://holoviews.org/Tutorials/Containers.html][HoloViews Documentation]]
   :ANKI_NOTE_ID: 1525385028228
   :END: 
*** Text
Select different points in HoloViews by category
#+BEGIN_SRC scala
hv.{{c1::HoloMap}}(d:{{c2::hv.Points}}(data[{{c3::data['category'] == d}}],
    {{c4::kdims=['x','y']}}) for d in {{c5::data['category'].unique()}})

#+END_SRC
*** Extra
